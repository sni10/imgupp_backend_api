# Руководство для разработчиков

Этот документ описывает нюансы сборки/конфигурации и тестирования именно этого проекта (Django + DRF, несколько приложений: photomanager, linkmanager, users). Информация предназначена для опытных разработчиков.

## 1) Сборка и конфигурация

- Поддерживаемые версии Python: 3.10–3.12 (под Django 5.x). Рекомендуется отдельное виртуальное окружение.
- Установка зависимостей (Windows PowerShell):
  - python -m venv .venv
  - .\.venv\Scripts\Activate.ps1
  - python -m pip install -U pip
  - pip install -r requirements.txt

- Ключевые внешние сервисы в прод/разработке:
  - MySQL: используется как основная БД (см. settings.DATABASES['default']). Требуемые env-переменные: DB_NAME, DB_USER, DB_PASSWORD, DB_HOST, DB_PORT.
  - Redis: используется как кэш (django-redis). Адрес по умолчанию: redis://redis:6379/1.
  - MongoDB (опционально): в settings задан второй подключатель через djongo (DATABASES['mongodb']). Зависимость djongo не закреплена в requirements.txt; подключайте осознанно и пиньте версию, если включаете эту интеграцию.

- Локальная разработка без внешних сервисов:
  - Для запуска тестов и изолированных сценариев можно перейти в «тестовый режим»: в нем автоматически используются SQLite и локальный кэш (LocMem), а список приложений урезан до базовых contrib.*.
  - Переключение выполняется автоматически, если:
    - запущена команда manage.py test ("test" присутствует в sys.argv), либо
    - установлена переменная окружения DJANGO_TEST=1/true/yes.

- Базовые команды Django (после активации venv и установки зависимостей):
  - Миграции: python manage.py makemigrations && python manage.py migrate
  - Создание суперпользователя: python manage.py createsuperuser
  - Запуск dev-сервера: python manage.py runserver 0.0.0.0:8000

- Переменные окружения, на которые стоит обратить внимание:
  - SECRET_KEY — используйте безопасное значение вне локалки.
  - ALLOWED_HOSTS, CSRF_TRUSTED_ORIGINS — для доступа через nginx/ingress.
  - MEDIA_URL/ROOT — в проекте MEDIA_URL равен '/', MEDIA_ROOT — папка 'media' в корне.

- Docker: в монорепозитории есть Dockerfile и docker-compose.yml (на уровень выше текущей папки). Используйте их при необходимости контейнеризации окружения (MySQL/Redis/приложение) — актуальные команды зависят от конкретного compose-файла.

## 2) Тестирование

### 2.1 Запуск тестов

- Рекомендуемый локальный режим (без MySQL/Redis):
  - $env:DJANGO_TEST = "1"
  - python manage.py test -v 2
  - При этом settings автоматически переключатся на SQLite и локальный кэш, а дополнительные приложения и внешние сервисы не потребуются.

- Запуск тестов конкретного приложения:
  - python manage.py test users -v 2
  - python manage.py test photomanager.tests -v 2

- Запуск отдельного тест-кейса/теста:
  - python manage.py test app_label.tests.test_module.TestClass -v 2
  - python manage.py test app_label.tests.test_module.TestClass.test_method -v 2

Примечание: В «боевом» режиме (без DJANGO_TEST и без команды test) проект ожидает наличие MySQL/Redis (и, при явном использовании, MongoDB). Позаботьтесь о валидных env и доступности сервисов.

### 2.2 Добавление тестов

- Структура: для новых тестов предпочтительно создавать модульную структуру per-app:
  - <app>/tests/__init__.py
  - <app>/tests/test_*.py

- Используйте стандартный Django TestCase/TransactionTestCase для тестов, задействующих ORM/транзакции. Для чистой логики — SimpleTestCase.
- Избегайте зависимостей от внешних сервисов в юнит-тестах. Используйте моки и/или «тестовый режим» settings. Если нужен кэш — rely on LocMemCache под DJANGO_TEST.

Пример простого теста (SimpleTestCase):

- Файл: photomanager/tests.py (можно перенести в photomanager/tests/test_sanity.py при рефакторинге структуры)

  from django.test import SimpleTestCase

  class SanityTests(SimpleTestCase):
      def test_math_works(self):
          self.assertEqual(2 + 2, 4)

### 2.3 Демонстрационный тест (в этом окружении)

- Для демонстрации процесса в среде без установленных Django-зависимостей был создан и запущен простой unittest-тест (tests_demo.py) командой:
  - python -m unittest -v tests_demo
- Результат: OK (1 test). Далее файл удалён, чтобы не засорять репозиторий (см. раздел 4: уборка артефактов).

## 3) Дополнительная информация для разработки

- Стиль кода: PEP 8, аннотации типов в публичных API. Рекомендуемые инструменты (при желании добавить в dev‑зависимости): ruff/flake8, isort, black.
- Миграции: держите их атомарными и обозримыми. В коммитах сопровождайте миграции кратким описанием изменения модели.
- Работа с медиа: MEDIA_URL='/' и MEDIA_ROOT='media'. Учитывайте это при генерации ссылок и тестировании статического/медийного контента. Для тестов избегайте записи крупных файлов, используйте временные директории (override_settings + tempfile) и фабрики.
- Кэш: в продакшне redis; в тестах/локально (DJANGO_TEST) — LocMemCache. Не завязывайтесь на особенности Redis в тестах (например, TTL точность).
- Безопасность: не хардкодьте секреты. Используйте переменные окружения. Проверьте CSRF/Allowed Hosts при интеграции с nginx/ingress.
- DRF и JWT: проект использует djangorestframework и simplejwt. Для интеграционных тестов аутентификации применяйте APIClient и выдачу токена через JWT эндпоинты.
- MongoDB: блок в settings добавлен как опциональный. Если включаете — зафиксируйте совместимую версию djongo и тестируйте отдельно. Для большинства задач достаточно SQL‑хранилища.

## 4) Процесс «чистого» тестирования и уборка артефактов

- Алгоритм для CI/локально, без внешних сервисов:
  1. Создать и активировать venv, установить зависимости.
  2. Установить $env:DJANGO_TEST = "1".
  3. Выполнить: python manage.py test -v 2.
  4. Убедиться в отсутствии новых артефактов в репозитории (кроме целевых файлов/изменений).

- Все временные демонстрационные файлы (например, tests_demo.py) следует удалять после использования. В этой ветке такой файл уже удалён.

## 5) Тонкости и «подводные камни»

- Минимальный INSTALLED_APPS в тестовом режиме: если вы тестируете код из приложений (users/linkmanager/photomanager), которые требуют регистраций моделей/сигналов/админки, включите их явно через @override_settings или задайте DJANGO_TEST=1 и вызов manage.py test так, чтобы Django всё равно нашёл ваши тесты до инициализации импортов, либо временно не минимизируйте список приложений, если это мешает вашим кейсам.
- Импорты из urls.py подтягивают include из приложений. Если тестам это мешает (например, при сильной изоляции), используйте ROOT_URLCONF=... в @override_settings на время теста.
- Для интеграционных тестов, которым всё же нужна реальная БД/кэш, поднимайте их через docker-compose и прокидывайте переменные окружения для MySQL/Redis.
